from queue_functions import *
from threading import Thread
from queue import Queue


# from Mesero import agregar_ordenes


class Cocinero():
    def __init__(self, queue1, queue2, tipos):
        self.queue_1 = queue1
        self.queue_2 = queue2
        self.tipos = tipos
        self.fillings = None if self.tipos[0] == 'quesadilla' or self.tipos[1] == 'quesadilla' else {"salsa": 150,
                                                                                                     "guacamole": 100,
                                                                                                     "cilantro": 200,
                                                                                                     "cebolla": 200}
        self.rest = None if self.tipos[0] == 'quesadilla' or self.tipos[1] == 'quesadilla' else 100  # 3 s / 100
        self.fan = None if self.tipos[0] == 'quesadilla' or self.tipos[1] == 'quesadilla' else 60  # 6 s / 60
        self.using_queue_1 = True

    def check_rest(self, rest_time):
        print(f"Tiempo restante al descanso = {self.rest}\n")
        if self.rest <= 5:
            print('----Descansando alv----')
            time.sleep(3)
            self.rest += 100
        self.rest -= rest_time

    def fan_time(self, fan_time):
        print(f"Tiempo del abanico = {self.fan}\n")
        if self.fan <= 5:
            print("\t > Prendimos abanico")
            time1 = time.time()
            while time.time() - time1 < 6:
                pass
            print(f"\t\t >>> Abanicamos {time.time() - time1} segundacos")
            self.fan += 60
        self.fan -= fan_time


    def atender_orden(self):
        spent_fillings = 0
        if self.using_queue_1:
            queue = self.queue_1
            num_queue = '1'
        elif not self.using_queue_1 and not self.queue_2.empty():
            queue = self.queue_2
            num_queue = '2'

        print("\n\nQueue que se esta usando: " + num_queue)

        if not queue.empty():
            orden = queue.get()
            orden['Answer']['start-time']= str(datetime.now())
            for batch in orden['orden']:
                if batch['status'] == 'open' and ((batch['meat'] == self.tipos[0] or batch['meat'] == self.tipos[1]) or self.tipos[0] == 'quesadilla'):
                    print(f"Batch antes: {batch}")
                    part_id = batch['part_id']
                    # print(batch['ingredients'])
                    if batch['quantity'] <= 5:
                        self.check_rest(batch['quantity'])
                        fan_thread = Thread(target=self.fan_time, args=(batch['quantity'],))
                        fan_thread.start()

                        orden['Answer']['steps'].append({"state":"running","action":"Doing tacos","part-id":part_id})

                        spent_fillings = int(batch['quantity'])
                        if self.tipos[0] != 'quesadilla' or (
                                batch['quantity'] == 0 and batch['type'] == 'quesadilla' and self.tipos[
                            0] != 'quesadilla'):
                            for ingredient in batch['ingredients']:
                                self.fillings[ingredient] -= spent_fillings
                        batch['quantity'] = 0
                        batch['status'] = 'closed'
                        orden['Answer']['steps'].append({"state": "Done", "action": "Batch completed", "part-id": part_id})
                        if self.using_queue_1:
                            self.using_queue_1 = False

                        print("Fillings: ", self.fillings)
                        print(f"Batch despues: {batch}")
                        print('\t\t >>> Batch terminado')

                        # Se regresa al objeto, y la orden que se quiere enviar a otro cocinero. El objeto aqui se regresa porque se necesita
                        # referencia a el, ya que se va a excluir de la lista en la funcion de agregar_ordenes en dum.py. Esto solo se envia cuando
                        # se termino el batch. Aun falta la funcionalidad de que va a pasar cuando la orden este completamente terminada jajaja salu2
                        return orden

                    elif batch['quantity'] > 5:
                        self.check_rest(5)
                        fan_thread = Thread(target=self.fan_time, args=(5,))
                        fan_thread.start()

                        if not (self.tipos != 'quesadilla' and batch['type'] == 'quesadilla'):
                            if self.tipos[0] != 'quesadilla' or (
                                    batch['quantity'] == 0 and batch['type'] == 'quesadilla' and self.tipos[
                                0] != 'quesadilla'):
                                for ingredient in batch['ingredients']:
                                    self.fillings[ingredient] -= 5
                            batch['quantity'] -= 5

                            orden['Answer']['steps'].append({"state": "Running", "action": "Doing tacos", "part-id": part_id})
                            self.queue_2.put(orden)
                            orden['Answer']['steps'].append({"state": "Waiting", "action": "Waiting for taquero", "part-id": part_id})

                            self.using_queue_1 = not self.using_queue_1
                            print("Fillings: ", self.fillings)
                            print(f"Batch despues: {batch}")
                            return
        else:
            print("El queue esta vacio alaverga")

            # Agregar descanso qui vacio
            return
